{

    private val db = FirebaseFirestore.getInstance()
    private val collectionRef = db.collection("ChildAccounts")  // Make this global

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        if (Build.VERSION.SDK_INT  >= Build.VERSION_CODES.TIRAMISU){
            requestNotificationPermission()
        }
        // Start the ForegroundService
        val serviceIntent = Intent(this, testForegroundService::class.java)
        serviceIntent.action = testForegroundService.CounterAction.START.name // Set action to start the service
        startService(serviceIntent)

        // Fetch app data from Firestore
//        fetchAppDataFromFirestore()

        // Get list of installed apps
//        val packageManager = packageManager
//        val installedApps = packageManager.getInstalledApplications(PackageManager.GET_META_DATA)
//            .filter { it.flags and ApplicationInfo.FLAG_SYSTEM == 0 }
//            .map { AppItem(it.loadLabel(packageManager).toString(), it.packageName) }

        // Compare installed apps with apps from Firestore
//        compareInstalledApps(installedApps)
    }

    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
    private fun requestNotificationPermission(){
        ActivityCompat.requestPermissions(
            this,
            arrayOf(Manifest.permission.POST_NOTIFICATIONS),
            100
        )
    }

    data class AppItem(val label: String, val packageName: String)

    private fun fetchAppDataFromFirestore() {
        // Reference to your collection
        val tempoChildId = "38749f37-c" //delete after testing

        // Construct a query to retrieve documents where childId equals the specified value
        val query = collectionRef.whereEqualTo("childId", tempoChildId)

        // Execute the query
        query?.addSnapshotListener { snapshot, exception ->
            if (exception != null) {
                Log.e("FirestoreData", "Error getting documents: ", exception)
                return@addSnapshotListener
            }

            if (snapshot != null) {
                for (document in snapshot.documents) {
                    // Access the "apps" map within the document
                    val appsMap = document["apps"] as? Map<String, Map<String, Any>> ?: continue

                    // Iterate over each entry in the "apps" map
                    for ((appName, appData) in appsMap) {
                        val label = appData["label"] as? String ?: ""
                        val isBlocked = appData["isBlocked"] as? Boolean ?: false
                        val status = if (isBlocked) "Locked" else "Unlocked"

                        // Log the app name along with its lock status
                        Log.d("AppListActivity", "$label : $status")
                    }
                }
            } else {
                Log.d("FirestoreData", "Current data: null")
            }
        }
    }

    private fun compareInstalledApps(installedApps: List<AppItem>) {
        // Reference to your collection
        val tempoChildId = "38749f37-c" //delete after testing

        // Construct a query to retrieve documents where childId equals the specified value
        val query = collectionRef.whereEqualTo("childId", tempoChildId)

        // Execute the query
        query?.get()?.addOnSuccessListener { documents ->
            for (document in documents) {
                // Access the "apps" map within the document
                val appsMap = document["apps"] as? MutableMap<String, Map<String, Any>> ?: mutableMapOf()

                // Iterate over each installed app
                installedApps.forEachIndexed { index, installedApp ->
                    val packageName = installedApp.packageName

                    // Check if the app from Firestore is installed
                    if (!appsMap.containsKey(packageName)) {
                        // The app is not in Firestore, add it
                        val newApp = mapOf(
                            "label" to installedApp.label,
                            "packageName" to packageName,
                            "isBlocked" to false // Assuming the default value is false
                        )
                        appsMap["app$index"] = newApp
                        Log.d("Comparison", "${installedApp.label} is installed and added to Firestore")
                    }
                }

                // Update the Firestore document with the modified app list
                document.reference.update("apps", appsMap)
                    .addOnSuccessListener {
                        Log.d("Firestore", "Apps list updated successfully")
                    }
                    .addOnFailureListener { exception ->
                        Log.e("Firestore", "Error updating apps list: ", exception)
                    }
            }
        }?.addOnFailureListener { exception ->
            Log.e("Comparison", "Error comparing apps: ", exception)
        }
    }

}